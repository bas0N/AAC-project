import os
from utils.input_generator_util import InputGeneratorUtil
from utils.testing_util import TestingUtil
from utils.input_parser_util import InputParserUtil
from utils.testing_util import TestingUtil
from algorithms.graph_size import GraphSizeCalculator
from utils.input_parser_util import InputParserUtil
from algorithms.distance_between_graphs import GraphDistanceCalculator
from algorithms.cycles import find_all_cycles, approximate_max_cycles, normalize_cycle
from algorithms.hamiltonian_cycles_min_extension import min_num_hamiltonian_extension_exact, min_num_hamiltonian_extension_approx
from algorithms.hamiltonian_cycles_number import count_hamiltonian_cycles_backtrack,count_hamiltonian_cycles_randomized_biased
from index import run_all_tests

def main():
    while True:
        print("===================================")
        print("       Graph Testing Project        ")
        print("===================================")
        print("1. Use prepared examples for all algorithms (run all algorithms on generated graphs)")
        print("2. Try your own examples (run a specific algorithm on a graph of your choice or generated by the program)")
        print("0. Exit")
        choice = input("Enter your choice: ").strip()

        if choice == '1':
            print("Running prepared examples...")
            run_all_tests()
            print("Prepared examples processed.")
            input("Press Enter to continue...")

        elif choice == '2':
            run_own_examples()

        elif choice == '0':
            print("Exiting...")
            break
        else:
            print("Invalid choice. Please try again.")
            input("Press Enter to continue...")

def run_own_examples():
    inputParserUtilInstance = InputParserUtil()
    inputGeneratorUtilInstance =  InputGeneratorUtil()
    graphDistanceCalculator = GraphDistanceCalculator()

    graph_functions_map = {
        '1': (GraphSizeCalculator.graph_size, "Finding the Size of the Graph"),
        '2': (graphDistanceCalculator.calculate_distance, "Finding the Distance Between Two Graphs"),
        '3': (find_all_cycles, "Finding the Max Cycle and All cycles in the Graph - Exact Algorithm"),
        '4': (approximate_max_cycles, "Finding the Max Cycle and all cycles in the Graph - Polynomial Time Approximation"),
        '5': (min_num_hamiltonian_extension_exact, "Finding the Minimum Extension to Achieve Hamiltonian Graph - Exact Algorithm"),
        '6': (min_num_hamiltonian_extension_approx, "Finding the Minimum Extension to Achieve Hamiltonian Graph - Polynomial Time Approach"),
        '7': (count_hamiltonian_cycles_backtrack, "Finding All Hamiltonian Cycles - Exact Algorithm"),
        '8': (count_hamiltonian_cycles_randomized_biased, "Finding All Hamiltonian Cycles - Polynomial Time Approach"),
    }
    while True:
        print("===================================")
        print("         Own Examples Menu          ")
        print("===================================")
        print("Select an algorithm:")
        print("1. Finding the Size of the Graph")
        print("2. Finding the Distance Between Two Graphs")
        print("3. Finding the Max Cycle and All cycles in the Graph - Exact Algorithm")
        print("4. Finding the Max Cycle and all cycles in the Graph - Polynomial Time Approximation")
        print("5. Finding the Minimum Extension to Achieve Hamiltonian Graph - Exact Algorithm")
        print("6. Finding the Minimum Extension to Achieve Hamiltonian Graph - Polynomial Time Approach")
        print("7. Finding All Hamiltonian Cycles - Exact Algorithm")
        print("8. Finding All Hamiltonian Cycles - Polynomial Time Approach")
        print("0. Return to Main Menu")
        alg_choice = input("Enter the algorithm number: ").strip()

        if alg_choice == '0':
            break
        elif alg_choice in [str(i) for i in range(1,9)]:
            print(f"Selected algorithm: {graph_functions_map[alg_choice][1]}")
            # Now choose input source
            input_choice = choose_input_source()
            if input_choice == '0':
                # Go back to the previous menu
                continue
            elif input_choice == '1':
                # User-provided file
                file_path = input("Enter absolute file path to the graph file: ").strip()
                if not os.path.isabs(file_path):
                    print("Error: The provided path is not absolute.")
                elif not os.path.isfile(file_path):
                    print("Error: File does not exist.")
                else:
                    func_obj, func_name = graph_functions_map[alg_choice]

                    print(f"Running Algorithm {func_name} on graph from file: {file_path}")
                    importedGraph = inputParserUtilInstance.read_matrix_file(file_path)
                    imported_graph_parsed = inputParserUtilInstance.parse_single_graph(importedGraph)
                    size = imported_graph_parsed['number_of_vertices']
                    print("Imported Graph Parsed",imported_graph_parsed, "is directed",imported_graph_parsed['is_directed'])
                    testingUtil = TestingUtil(func_obj)
                    # TODO: Implement logic to run the selected algorithm on the imported
                    print(f"Running Algorithm {func_name} on the imported graph.")
                    if(alg_choice=='1'):
                        testingUtil.run_test((imported_graph_parsed['adjacency_matrix'],imported_graph_parsed['is_directed']),func_name + f" size: {size}" + f" directed: {imported_graph_parsed['is_directed']}" )
                    elif(alg_choice=='2'):
                        file_path_to_compare = input("Enter absolute file path to the graph file to compare: ").strip()
                        importedGraph_to_compare = inputParserUtilInstance.read_matrix_file(file_path_to_compare)
                        imported_graph_to_compare_parsed = inputParserUtilInstance.parse_single_graph(importedGraph_to_compare)
                        print("Graph to Compare Parsed",imported_graph_to_compare_parsed, "is directed",imported_graph_to_compare_parsed['is_directed'])
                        testingUtil.run_test((imported_graph_parsed['adjacency_matrix'],imported_graph_to_compare_parsed['adjacency_matrix'],imported_graph_parsed["is_directed"]), func_name + f" size: {size}" + f" directed: {imported_graph_parsed['is_directed']}")
                    elif(alg_choice=='3'):
                        testingUtil.run_test({"adjacency_matrix":imported_graph_parsed['adjacency_matrix'],"is_directed":imported_graph_parsed['is_directed']},func_name + f" size: {size}" +f" directed: {imported_graph_parsed['is_directed']}")
                    elif(alg_choice=='4'):
                        iterations = input("Enter the number of iterations: ").strip()
                        if(iterations.isdigit()):
                            testingUtil.run_test({"adjacency_matrix":imported_graph_parsed['adjacency_matrix'],"is_directed":imported_graph_parsed['is_directed'],"iterations":int(iterations)},func_name + f" size: {size}" +f" directed: {imported_graph_parsed['is_directed']}" + f" iterations: {iterations}")
                        else:
                            print("Invalid number of iterations")
                    elif(alg_choice=='5'):
                        testingUtil.run_test({"adjacency_matrix":imported_graph_parsed['adjacency_matrix'],"is_directed":imported_graph_parsed['is_directed']},func_name + f" size: {size}" +f" directed: {imported_graph_parsed['is_directed']}")
                    elif(alg_choice=='6'):
                        iterations = input("Enter the number of iterations: ").strip()
                        testingUtil.run_test({"adjacency_matrix":imported_graph_parsed['adjacency_matrix'],"is_directed":imported_graph_parsed['is_directed'],"iterations":int(iterations)},func_name + f" size: {size}" +f" directed: {imported_graph_parsed['is_directed']}" + f" iterations: {iterations}")
                    elif(alg_choice=='7'):
                        testingUtil.run_test({"adjacency_matrix":imported_graph_parsed['adjacency_matrix'],"is_directed":imported_graph_parsed['is_directed']},func_name + f"size: {size}" +f" directed: {imported_graph_parsed['is_directed']}")
                    elif(alg_choice=='8'):
                        iterations = input("Enter the number of iterations: ").strip()
                        testingUtil.run_test({"adjacency_matrix":imported_graph_parsed['adjacency_matrix'],"is_directed":imported_graph_parsed['is_directed'],"iterations":int(iterations)},func_name + f"size: {size}" +f" directed: {imported_graph_parsed['is_directed']}" + f" iterations: {iterations}")
                    # Insert your algorithm execution code here
                input("Press Enter to continue...")

            elif input_choice == '2':
                # Autogenerated graph
                size_str = input("Enter the size of the graph (number of nodes): ").strip()
                density_str = input("Enter the density of the graph (0 to 1): ").strip()

                # Basic validation
                if not size_str.isdigit() or int(size_str) <= 0:
                    print("Error: Size must be a positive integer.")
                else:
                    try:
                        density = float(density_str)
                        if density < 0 or density > 1:
                            print("Error: Density must be between 0 and 1.")
                        else:
                            size = int(size_str)
                            # TODO: Implement logic to generate graph based on size and density
                            # and run the selected algorithm on it.
                            func_obj, func_name = graph_functions_map[alg_choice]

                            print(f"Generating graph of size {size} with density {density} and running Algorithm {func_name}.")
                            is_graph_directed, generated_graph = inputGeneratorUtilInstance.generate_random_graph_with_density(size, density)
                            generated_graph_parsed = inputParserUtilInstance.parse_single_graph(generated_graph)
                            print("Generated Graph Parsed",generated_graph_parsed, "is directed",generated_graph_parsed['is_directed'])
                            testingUtil = TestingUtil(func_obj)
                            # TODO: Implement logic to run the selected algorithm on the generated graph
                            print(f"Running Algorithm {func_name} on the generated graph.")
                            if(alg_choice=='1'):
                                testingUtil.run_test((generated_graph_parsed['adjacency_matrix'],generated_graph_parsed['is_directed']),func_name + f" size: {size}" + f" directed: {generated_graph_parsed['is_directed']}" )
                            elif(alg_choice=='2'):
                                is_graph_to_compare_directed, graph_to_compare = inputGeneratorUtilInstance.generate_random_graph_with_density(size, density)
                                graph_to_compare_parsed = inputParserUtilInstance.parse_single_graph(graph_to_compare)
                                print("Graph to Compare Parsed",graph_to_compare_parsed, "is directed",graph_to_compare_parsed['is_directed'])
                                testingUtil.run_test((generated_graph_parsed['adjacency_matrix'],graph_to_compare_parsed['adjacency_matrix'],generated_graph_parsed["is_directed"]), func_name + f" size: {size}" + f" directed: {generated_graph_parsed['is_directed']}")
                            elif(alg_choice=='3'):
                                testingUtil.run_test({"adjacency_matrix":generated_graph_parsed['adjacency_matrix'],"is_directed":generated_graph_parsed['is_directed']},func_name + f" size: {size}" +f" directed: {generated_graph_parsed['is_directed']}")
                            elif(alg_choice=='4'):
                                iterations = input("Enter the number of iterations: ").strip()
                                if(iterations.isdigit()):
                                    testingUtil.run_test({"adjacency_matrix":generated_graph_parsed['adjacency_matrix'],"is_directed":generated_graph_parsed['is_directed'],"iterations":int(iterations)},func_name + f" size: {size}" +f" directed: {generated_graph_parsed['is_directed']}" + f" iterations: {iterations}")
                                else:
                                    print("Invalid number of iterations")
                            elif(alg_choice=='5'):
                                testingUtil.run_test({"adjacency_matrix":generated_graph_parsed['adjacency_matrix'],"is_directed":generated_graph_parsed['is_directed']},func_name + f" size: {size}" +f" directed: {generated_graph_parsed['is_directed']}")
                            elif(alg_choice=='6'):
                                iterations = input("Enter the number of iterations: ").strip()
                                testingUtil.run_test({"adjacency_matrix":generated_graph_parsed['adjacency_matrix'],"is_directed":generated_graph_parsed['is_directed'],"iterations":int(iterations)},func_name + f" size: {size}" +f" directed: {generated_graph_parsed['is_directed']}" + f" iterations: {iterations}")
                            elif(alg_choice=='7'):
                                testingUtil.run_test({"adjacency_matrix":generated_graph_parsed['adjacency_matrix'],"is_directed":generated_graph_parsed['is_directed']},func_name + f"size: {size}" +f" directed: {generated_graph_parsed['is_directed']}")
                            elif(alg_choice=='8'):
                                iterations = input("Enter the number of iterations: ").strip()
                                testingUtil.run_test({"adjacency_matrix":generated_graph_parsed['adjacency_matrix'],"is_directed":generated_graph_parsed['is_directed'],"iterations":int(iterations)},func_name + f"size: {size}" +f" directed: {generated_graph_parsed['is_directed']}" + f" iterations: {iterations}")
                    except ValueError:
                        print("Error: Density must be a valid floating-point number.")
                input("Press Enter to continue...")
            else:
                print("Invalid choice. Please try again.")
                input("Press Enter to continue...")
        else:
            print("Invalid choice. Please try again.")
            input("Press Enter to continue...")

def choose_input_source():
    while True:
        print("===================================")
        print("         Input Source Menu          ")
        print("===================================")
        print("1. Own input file")
        print("2. Generate graph")
        print("0. Return to Previous Menu")
        choice = input("Enter your choice: ").strip()

        if choice in ['0','1','2']:
            return choice
        else:
            print("Invalid choice. Please try again.")
            input("Press Enter to continue...")

if __name__ == "__main__":
    main()
